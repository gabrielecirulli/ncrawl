// Generated by CoffeeScript 1.3.3
(function() {
  var Scan, colors, commands, fs, modules, queue, targets, _;

  colors = require('colors');

  fs = require('fs');

  _ = require('underscore');

  commands = require('./commands');

  modules = require('./modules');

  targets = require('./targets');

  queue = require('./queue');

  Scan = require('./scan');

  process.stdin.resume();

  module.exports = function(options, complete) {
    var completedScans, currentProgress, finish, i, increment, lastUpdatedProgress, parsedTargets, progress, progressInterval, remainingScans, reporter, startTime, target, totalModules, totalTargets, _results;
    if (options.finish) {
      complete = options.finish;
    }
    modules.run(options.modules);
    queue.maxOperations(options.operations);
    reporter = options.reporter;
    if (_.isString(reporter)) {
      reporter = require(require.resolve("../reporters/" + options.reporter));
    }
    options = _.extend(options, reporter);
    if (!_.isArray(options.targets)) {
      parsedTargets = targets.run(options.targets);
    }
    totalTargets = targets.amount();
    totalModules = modules.amount();
    if (!options.error) {
      options.error = function(code, msg) {
        throw new Error(msg);
      };
    }
    if (totalTargets === 0) {
      options.error(1, 'No targets selected');
    }
    if (totalModules === 0) {
      options.error(2, 'No modules selected');
    }
    if (totalTargets === 0 || totalModules === 0) {
      return complete();
    }
    if (options.before) {
      options.before({
        totalTargets: totalTargets,
        totalModules: totalModules
      });
    }
    increment = (totalModules / totalTargets) * 100 / totalModules;
    currentProgress = 0;
    lastUpdatedProgress = 0;
    completedScans = 0;
    startTime = Date.now();
    progress = function() {
      var elapsed, eta;
      if (completedScans === 0) {
        return;
      }
      elapsed = Date.now() - startTime;
      eta = ((elapsed * (totalTargets / completedScans - 1)) / 1000).toFixed(1);
      return options.progress({
        progress: currentProgress,
        elapsed: elapsed,
        eta: eta,
        totalScans: totalTargets,
        completedScans: completedScans
      });
    };
    if (options.progressInterval) {
      progressInterval = setInterval(progress, options.progressInterval);
    }
    finish = function() {
      var data;
      clearInterval(progressInterval);
      data = {
        start: startTime,
        end: Date.now(),
        took: Date.now() - startTime
      };
      if (options.after) {
        options.after(data);
      }
      return complete();
    };
    remainingScans = totalTargets;
    _results = [];
    for (i in parsedTargets) {
      target = parsedTargets[i];
      _results.push((function(i, target) {
        return queue.add(function(finished) {
          var scanReporter;
          scanReporter = new options.Reporter(target, options);
          return new Scan(+i, target, options, scanReporter, finished, function() {
            completedScans++;
            currentProgress += increment;
            if (!options.progressInterval && options.progress) {
              progress();
            }
            if (--remainingScans === 0) {
              return finish();
            }
          });
        });
      })(i, target));
    }
    return _results;
  };

}).call(this);
