// Generated by CoffeeScript 1.3.3
(function() {
  var Scan, async, dns, net, services, _,
    __slice = [].slice;

  services = require('./services');

  async = require('async');

  dns = require('dns');

  net = require('net');

  _ = require('underscore');

  Scan = (function() {

    function Scan(o) {
      var module, name, _ref,
        _this = this;
      this.id = o.id;
      this.target = o.target;
      this.options = o.options;
      this.reporter = o.reporter;
      this.queueDone = o.queueDone;
      this.modules = o.modules;
      this.done = o.done;
      this.queue = o.queue;
      this.call('start', this.id, this.target);
      this.totalModules = o.totalModules;
      this.results = {};
      _ref = this.modules;
      for (name in _ref) {
        module = _ref[name];
        this.results[name] = {
          error: true
        };
      }
      this.info = {
        target: this.target,
        id: this.id,
        type: [],
        mx: [],
        txt: [],
        srv: [],
        ns: [],
        cname: [],
        resolve: {},
        isIP: false,
        ip: null,
        hostname: null
      };
      if (net.isIP(this.target)) {
        this.info.isIP = true;
        this.info.ip = this.target;
      } else {
        this.info.hostname = this.target;
      }
      this.dns(function() {
        var port, _i, _len, _ref1, _ref2, _results;
        _this.call('info', _this.info);
        _ref1 = _this.modules;
        for (name in _ref1) {
          module = _ref1[name];
          _this.addModule(name, module);
        }
        _ref2 = _this.options.ports;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          port = _ref2[_i];
          _results.push(_this.addPort(port));
        }
        return _results;
      });
    }

    Scan.prototype.call = function() {
      var args, name;
      name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (_.isFunction(this.reporter[name])) {
        this.reporter[name].apply(this.reporter, args);
      }
      if (_.isFunction(this.options[name])) {
        return this.options[name].apply(this.options, args);
      }
    };

    Scan.prototype.dns = function(finish) {
      var next,
        _this = this;
      next = function() {
        _this.queueDone();
        return finish();
      };
      return async.series({
        reverse: function(callback) {
          return dns.resolve(_this.target, function(err, results) {
            if (err) {
              return callback();
            }
            if (results && !_this.info.ip) {
              _this.info.ip = results[0];
            }
            _this.info.resolve = {};
            return async.forEach(results, function(item, done) {
              return dns.reverse(item, function(err, results) {
                if (results && !_this.info.hostname) {
                  _this.info.hostname = results[0];
                }
                _this.info.resolve[item] = results;
                return done();
              });
            }, callback);
          });
        },
        mx: function(callback) {
          if (!_this.info.ip) {
            return next(_this.results = {});
          }
          if (!_this.info.hostname) {
            return next();
          }
          return dns.resolveMx(_this.info.hostname, function(err, records) {
            if (records) {
              _this.info.mx = records;
            }
            return callback();
          });
        },
        txt: function(callback) {
          return dns.resolveTxt(_this.info.hostname, function(err, records) {
            if (records) {
              _this.info.txt = records;
            }
            return callback();
          });
        },
        srv: function(callback) {
          return dns.resolveSrv(_this.info.hostname, function(err, records) {
            if (records) {
              _this.info.srv = records;
            }
            return callback();
          });
        },
        ns: function(callback) {
          return dns.resolveNs(_this.info.hostname, function(err, records) {
            if (records) {
              _this.info.ns = records;
            }
            return callback();
          });
        },
        cname: function(callback) {
          return dns.resolveCname(_this.info.hostname, function(err, records) {
            if (records) {
              _this.info.cname = records;
            }
            return callback();
          });
        },
        next: next
      });
    };

    Scan.prototype.identify = function(device) {
      this.info.type.push(device);
      return this.call('identify', {
        device: device,
        id: this.id
      });
    };

    Scan.prototype.addModule = function(name, obj) {
      var _this = this;
      return this.queue.add(function(finished) {
        var start;
        start = Date.now();
        return _this.checkPort(obj.port, function(error) {
          if (error) {
            _this.scanDone(name, {
              module: name,
              port: obj.port,
              error: true,
              start: start,
              finish: Date.now(),
              took: Date.now() - start
            });
            return finished();
          } else {
            return _this.startModule(name, obj, finished);
          }
        });
      });
    };

    Scan.prototype.addPort = function(port) {
      var _this = this;
      return this.queue.add(function(finished) {
        var start;
        start = Date.now();
        return _this.checkPort(port, function(error) {
          var info;
          info = services.getByPort(port);
          _this.scanDone(info.name || 'port', {
            port: port,
            data: {
              port: port
            },
            error: error,
            start: start,
            finish: Date.now(),
            took: Date.now() - start
          });
          return finished();
        });
      });
    };

    Scan.prototype.checkPort = function(port, callback) {
      var error, next, socket, timeout,
        _this = this;
      socket = new net.Socket;
      error = true;
      next = function() {
        socket.destroy();
        clearTimeout(timeout);
        return callback(error);
      };
      socket.on('connect', function() {
        error = false;
        return socket.destroy();
      });
      timeout = setTimeout(next, this.options.timeout);
      socket.on('error', function() {});
      socket.on('close', next);
      return socket.connect(port, this.target);
    };

    Scan.prototype.startModule = function(name, obj, finished) {
      var module, start,
        _this = this;
      start = Date.now();
      module = new obj.Module(this.target, this.options, this.identify.bind(this));
      return module.start(function(result) {
        var check, data, device, reg, types, values, _ref;
        if (result == null) {
          result = {};
        }
        result.port = obj.port;
        result.finish = Date.now();
        result.start = start;
        result.took = result.finish - result.start;
        _ref = obj.identities;
        for (device in _ref) {
          types = _ref[device];
          for (check in types) {
            values = types[check];
            if (!(result.data && (data = result.data[check]))) {
              continue;
            }
            reg = new RegExp("(" + (values.join('|')) + "})", 'i');
            if (reg.test(data)) {
              _this.identify(device);
            }
          }
        }
        finished();
        return _this.scanDone(name, result);
      });
    };

    Scan.prototype.scanDone = function(name, result) {
      if (result == null) {
        result = {};
      }
      result.module = name;
      result.id = this.id;
      result.data = result.data || {};
      if (!result.error || result.error && this.options.errors) {
        this.results[name] = result;
        this.call('result', name, result);
      } else {
        delete this.results[name];
      }
      if (--this.totalModules === 0) {
        return this.finish();
      }
    };

    Scan.prototype.finish = function() {
      if (Object.keys(this.results).length === 0 && !this.options.empty) {
        return this.done();
      }
      this.call('finish', this.id, this.info, this.results);
      return this.done();
    };

    return Scan;

  })();

  module.exports = Scan;

}).call(this);
